# Voyager Ads - AI Coding Agent Instructions

This file is adapted from the existing Copilot instructions in the workspace (`voyager-pwa` and `voyager-RN`) and includes an explicit Accessibility section so that generated code meets WCAG and ARIA best practices.

## Purpose
This document provides guardrails for AI-assisted code changes within the `voyager-ads` project. Follow these guidelines to preserve architecture, testing discipline, and accessibility.

## Development Basics
- Frontend: React + TypeScript (Vite)
- Keep code in `src/`, use functional components and hooks
- Run type checks: `npx tsc --noEmit`
- Run dev server: `npm run dev`

## Critical Rules
- Verify TypeScript compilation and run tests before claiming completion.
- Do not modify production code solely to make tests pass; fix tests or mocks instead.
- Preserve project structure and naming conventions.

## Accessibility (NEW)
All generated UI code must consider accessibility from the start. Add or verify the following when modifying or adding components:

- Semantic HTML: Prefer `header`, `nav`, `main`, `section`, `footer`, `button`, `form`, `label`, `input`.
- ARIA: Use ARIA roles/labels when native semantics are insufficient. Example:
  - Carousels: include `aria-roledescription="carousel"`, `role="group"` for track, `aria-hidden` on non-visible slides, and an `aria-live="polite"` region announcing slide changes.
  - Dialogs/modals: use `role="dialog"`, `aria-modal="true"`, and focus trap.
- Images: Provide meaningful `alt` text for informational images. Decorative images should use `alt=""` and `role="presentation"`.
- Keyboard: Ensure all interactive controls are reachable and operable via keyboard (Tab, Enter/Space, Arrow keys where appropriate).
- Focus states: Visible focus styles for interactive elements. Use `:focus-visible` when possible.
- Contrast: Maintain text/background contrast meeting WCAG AA thresholds (4.5:1 for normal text, 3:1 for large text).
- Motion: Respect `prefers-reduced-motion` and provide options to disable non-essential animations.
- Testing: Use automated accessibility testing (axe, jest-axe) and manual testing with a screen reader (VoiceOver/NVDA) for critical flows.

## Example: Accessible Carousel
- No visual controls required for this project’s hero carousel; include an `aria-live` region to announce `Showing slide X of N` on change.
- Ensure `img` elements have descriptive `alt` text.

## Cost & External APIs
- Consider cost implications before adding third-party APIs (OpenAI, Google Places, SerpAPI, Stripe).

## Testing & CI
- Add tests for behavior where appropriate. Use `__mocks__` for external services.
- Ensure CI runs type-checks and tests before merge.

## When Unsure
Ask for clarification — do not assume external API contracts, platform behavior, or copy changes.

---

*This file was generated by the AI assistant based on existing workspace guidelines and extended with accessibility requirements.*

## Directory Grouping & Maintainability
To keep the repo understandable and maintainable for other engineers, prefer grouping related files into meaningful, feature-oriented directories rather than many single-purpose folders. Add this guidance to new and existing PRs:

- **Feature folders:** Group components, hooks, styles and tests by feature or screen. Example structure:
  - `src/pages/` — route/screen components
  - `src/components/common/` — small shared UI (buttons, inputs, icons)
  - `src/components/landing/` — landing-specific components (Hero, Carousel)
  - `src/hooks/` — feature-named hooks (e.g., `useAuth`, `useAIGeneration`)
  - `src/services/` — business logic and external APIs
  - `src/repositories/` — data access layer
  - `src/assets/ads/` — ad images and mockups
  - `src/styles/` — shared CSS variables and global styles

- **Avoid proliferation:** Don't create one-off top-level directories for single files. If a folder would contain fewer than 3 related files, prefer placing the file in an existing feature or `common` folder.

## Architecture & Code Quality Criteria
All changes should align with S.O.L.I.D principles and React best practices. At a minimum:

- **Single Responsibility:** Each component, hook, and service should have one clear purpose.
- **Open/Closed:** Prefer extension over modification; add new modules or optional props instead of changing existing behavior when possible.
- **Dependency Inversion:** Higher-level modules should depend on interfaces/abstractions, not concrete implementations. Use small adapters for platform-specific code.
- **Interface Segregation:** Keep APIs small and purpose-specific; avoid large multi-purpose interfaces.
- **Liskov Substitution:** Implement substitutes that honor the expected contracts.

## React Best Practices
- Use functional components and hooks; avoid class components.
- Keep components presentational where possible; move logic to hooks or services.
- Prefer composition over deep prop drilling; use context for global state only when necessary.
- Use TypeScript with strict typing; avoid `any` unless absolutely necessary and justified in PR.
- Keep CSS scoped to components or use a shared token system in `src/styles/`.

## Vite & Performance
- Use Vite dev server for local development (`npm run dev`).
- Keep bundle size in mind: lazy-load large route components with dynamic imports and `React.lazy`/`Suspense` where appropriate.
- Avoid importing large third-party libraries in many small components; centralize heavy deps in services.

## Responsiveness
- Design for mobile-first: ensure components layout correctly at small widths and scale up.
- Use flexible units (rem, %) and CSS Flexbox/Grid.
- Verify keyboard and touch interactions work well across breakpoints.
- Add visual tests or storybook stories for critical responsive components when possible.

## Repo Changes & Refactors
- When proposing to move or reorganize files, include a short migration note in the PR describing the new layout and a plan for updating imports.
- Do NOT move files automatically in-wide refactors without reviewer approval. Offer a follow-up PR that performs the reorganization if maintainers agree.

## Code Cleanliness & Troubleshooting
To keep the codebase clear and reviewable, do NOT leave dead code or commented-out experiments in the repository. Follow these rules when working and troubleshooting:

- **Remove dead code:** Delete unused components, styles, helpers, and tests once a change is finalized. Before deleting, search for all references and update imports; run `npx tsc --noEmit` to ensure nothing breaks.
- **Document troubleshooting:** When debugging or trying an experimental approach, record the steps you took, commands run, and why a recommendation succeeded or failed. Put these notes in the PR description or `docs/TROUBLESHOOTING.md` so reviewers can follow the investigation.
- **Remove failed recommendations:** If an experiment or suggested change is abandoned, remove its code and any test artifacts; summarize in the PR why it was removed to avoid confusion.
- **Avoid commented experiments:** Do not keep large blocks of commented-out code in production files — use a branch or draft PR for experiments instead.
- **Small, reversible changes:** Keep PRs focused and small so it's easy to revert or iterate; include migration notes for any structural changes.

