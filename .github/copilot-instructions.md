# Voyager Ads - AI Coding Agent Instructions

This file is adapted from the existing Copilot instructions in the workspace (`voyager-pwa` and `voyager-RN`) and includes an explicit Accessibility section so that generated code meets WCAG and ARIA best practices.

## Purpose
This document provides guardrails for AI-assisted code changes within the `voyager-ads` project. Follow these guidelines to preserve architecture, testing discipline, and accessibility.

## Development Basics
- Frontend: React + TypeScript (Vite)
- Keep code in `src/`, use functional components and hooks
- Run type checks: `npx tsc --noEmit`
- Run dev server: `npm run dev`

## Critical Rules
- Verify TypeScript compilation and run tests before claiming completion.
- Do not modify production code solely to make tests pass; fix tests or mocks instead.
- Preserve project structure and naming conventions.

## Accessibility (NEW)
All generated UI code must consider accessibility from the start. Add or verify the following when modifying or adding components:

- Semantic HTML: Prefer `header`, `nav`, `main`, `section`, `footer`, `button`, `form`, `label`, `input`.
- ARIA: Use ARIA roles/labels when native semantics are insufficient. Example:
  - Carousels: include `aria-roledescription="carousel"`, `role="group"` for track, `aria-hidden` on non-visible slides, and an `aria-live="polite"` region announcing slide changes.
  - Dialogs/modals: use `role="dialog"`, `aria-modal="true"`, and focus trap.
- Images: Provide meaningful `alt` text for informational images. Decorative images should use `alt=""` and `role="presentation"`.
- Keyboard: Ensure all interactive controls are reachable and operable via keyboard (Tab, Enter/Space, Arrow keys where appropriate).
- Focus states: Visible focus styles for interactive elements. Use `:focus-visible` when possible.
- Contrast: Maintain text/background contrast meeting WCAG AA thresholds (4.5:1 for normal text, 3:1 for large text).
- Motion: Respect `prefers-reduced-motion` and provide options to disable non-essential animations.
- Testing: Use automated accessibility testing (axe, jest-axe) and manual testing with a screen reader (VoiceOver/NVDA) for critical flows.

## Example: Accessible Carousel
- No visual controls required for this project’s hero carousel; include an `aria-live` region to announce `Showing slide X of N` on change.
- Ensure `img` elements have descriptive `alt` text.

## Cost & External APIs
- Consider cost implications before adding third-party APIs (OpenAI, Google Places, SerpAPI, Stripe).

## Testing & CI
- Add tests for behavior where appropriate. Use `__mocks__` for external services.
- Ensure CI runs type-checks and tests before merge.

## When Unsure
Ask for clarification — do not assume external API contracts, platform behavior, or copy changes.

## Evidence & Suggested Changes
- Do not add unsolicited features or UI elements without demonstrable evidence or an explicit request. When proposing changes beyond the scoped request, include a clear rationale and cite supporting sources or data. Avoid speculative or random suggestions that are not backed by evidence.

---

*This file was generated by the AI assistant based on existing workspace guidelines and extended with accessibility requirements.*

## Directory Grouping & Maintainability
To keep the repo understandable and maintainable for other engineers, prefer grouping related files into meaningful, feature-oriented directories rather than many single-purpose folders. Add this guidance to new and existing PRs:

- **Feature folders:** Group components, hooks, styles and tests by feature or screen. Example structure:
  - `src/pages/` — route/screen components
  - `src/components/common/` — small shared UI (buttons, inputs, icons)
  - `src/components/landing/` — landing-specific components (Hero, Carousel)
  - `src/hooks/` — feature-named hooks (e.g., `useAuth`, `useAIGeneration`)
  - `src/services/` — business logic and external APIs
  - `src/repositories/` — data access layer
  - `src/assets/ads/` — ad images and mockups
  - `src/styles/` — shared CSS variables and global styles

- **Avoid proliferation:** Don't create one-off top-level directories for single files. If a folder would contain fewer than 3 related files, prefer placing the file in an existing feature or `common` folder.

## Architecture & Code Quality Criteria
All changes should align with S.O.L.I.D principles and React best practices. At a minimum:

- **Single Responsibility:** Each component, hook, and service should have one clear purpose.
- **Open/Closed:** Prefer extension over modification; add new modules or optional props instead of changing existing behavior when possible.
- **Dependency Inversion:** Higher-level modules should depend on interfaces/abstractions, not concrete implementations. Use small adapters for platform-specific code.
- **Interface Segregation:** Keep APIs small and purpose-specific; avoid large multi-purpose interfaces.
- **Liskov Substitution:** Implement substitutes that honor the expected contracts.

## React Best Practices
- Use functional components and hooks; avoid class components.
- Keep components presentational where possible; move logic to hooks or services.
- Prefer composition over deep prop drilling; use context for global state only when necessary.
- Use TypeScript with strict typing; avoid `any` unless absolutely necessary and justified in PR.
- Keep CSS scoped to components or use a shared token system in `src/styles/`.

## Vite & Performance
- Use Vite dev server for local development (`npm run dev`).
- Keep bundle size in mind: lazy-load large route components with dynamic imports and `React.lazy`/`Suspense` where appropriate.
- Avoid importing large third-party libraries in many small components; centralize heavy deps in services.

## Responsiveness
- Design for mobile-first: ensure components layout correctly at small widths and scale up.
- Use flexible units (rem, %) and CSS Flexbox/Grid.
- Verify keyboard and touch interactions work well across breakpoints.
- Add visual tests or storybook stories for critical responsive components when possible.

## Repo Changes & Refactors
- When proposing to move or reorganize files, include a short migration note in the PR describing the new layout and a plan for updating imports.
- Do NOT move files automatically in-wide refactors without reviewer approval. Offer a follow-up PR that performs the reorganization if maintainers agree.

## Code Cleanliness & Troubleshooting
To keep the codebase clear and reviewable, do NOT leave dead code or commented-out experiments in the repository. Follow these rules when working and troubleshooting:

- **Remove dead code:** Delete unused components, styles, helpers, and tests once a change is finalized. Before deleting, search for all references and update imports; run `npx tsc --noEmit` to ensure nothing breaks.
- **Document troubleshooting:** When debugging or trying an experimental approach, record the steps you took, commands run, and why a recommendation succeeded or failed. Put these notes in the PR description or `docs/TROUBLESHOOTING.md` so reviewers can follow the investigation.
- **Remove failed recommendations:** If an experiment or suggested change is abandoned, remove its code and any test artifacts; summarize in the PR why it was removed to avoid confusion.
- **Avoid commented experiments:** Do not keep large blocks of commented-out code in production files — use a branch or draft PR for experiments instead.
- **Small, reversible changes:** Keep PRs focused and small so it's easy to revert or iterate; include migration notes for any structural changes.

Security & Privacy Requirements

AI-generated code must follow secure-by-default practices:

Never hardcode secrets, API keys, tokens, or credentials.

Use environment variables (import.meta.env for Vite) for sensitive values.

Do not log sensitive user data (PII, auth tokens, payment info).

Validate and sanitize all user inputs.

Use HTTPS-only endpoints for external communication.

Follow the principle of least privilege for API access.

Avoid introducing XSS, CSRF, or injection vulnerabilities.

State Management Guidelines

Maintain predictable and scalable state handling:

Prefer local component state when possible.

Use React Context sparingly for truly global state.

Avoid unnecessary global stores.

Keep server state separate from UI state.

Normalize complex data structures to prevent duplication.

Ensure async state updates handle loading and error states.

Error Handling & Observability

Generated code must fail safely and visibly:

Use error boundaries for critical UI sections.

Provide user-friendly error messages.

Log errors to a central logging mechanism if available.

Avoid silent failures.

Handle network timeouts and retries where appropriate.

Internationalization (i18n) Readiness

Design UI to support future localization:

Avoid hardcoding text directly in components when feasible.

Keep strings externalizable.

Support RTL layouts where possible.

Use locale-aware formatting for dates, numbers, and currencies.

UX Consistency & Design Alignment

Maintain a cohesive product experience:

Follow existing design system, spacing, typography, and color tokens.

Avoid introducing new visual patterns without justification.

Ensure interactive elements have clear affordances.

Maintain consistent loading indicators and feedback patterns.

Avoid layout shifts during async operations.

Data Fetching Best Practices

Ensure efficient and predictable API usage:

Debounce user-triggered queries (e.g., search inputs).

Cancel stale requests when components unmount.

Avoid duplicate requests for identical data.

Cache responses when appropriate.

Respect API rate limits and cost implications.

Documentation Requirements

AI-generated changes should be understandable to human engineers:

Add concise comments for non-obvious logic.

Update README or relevant docs when introducing new features.

Document public interfaces and props.

Include usage examples for reusable components when helpful.

Review Readiness Checklist

Before considering a task complete, verify:

Code compiles without TypeScript errors.

Tests pass locally.

Accessibility requirements are met.

No console errors or warnings.

No unused imports or variables.

Performance impact is reasonable.

Security considerations have been addressed.